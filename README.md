# **ДЗ 3 по Программированию на C++**

## Сборка и запуск

Для запуска заполнить типы данных и размеры поля как опции компилятора(пример в `CMakeLists.txt`), выполнить

```bash
cmake .
make SE2_CPP_HW2
./SE2_CPP_HW2 ... # Опции запуска
```

Пример опций для запуска:

```cpp
--p-type=FIXED(64,8)
--v-type=FIXED(64,8)
--v-flow-type=FIXED(64,8)
--field=../field.txt
--threads-count=1 // Минимум 1
```

## Алгоритмические улучшения

- Множество небольших изменений (range-based итерирование по `delta`, передача `Fixed` по ссылке вместо копирования,
  упрощение выражений в if-выражениях, удаление неиспользуемых переменных и кода для их
  подсчёта(`eps`,`inf`, `total_delta_p`))
- Тройной вызов ParamField.swap заменён на одинарный swap
- `propagate_stop` переведена из рекурсивной dfs в циклическую bfs для снижения накладных расходов
- В коде, заполняющем velocity_flow добавлено:
  ```cpp
  if (t > int64_t(0)) {
    prop = true;
    --y;
  }
  ```
  что позволяет уменьшить число лишних проходов по циклу(в том числе по
  неизменённым ячейкам)

  Тесты показывают ускорение примерно на 10%

- В коде метода `propagate_flow` изменено с
  ```cpp
  auto [t, prop, end] = propagate_flow(nx, ny, vp);
  ```
  на
  ```cpp
  do {
      std::tie(t, prop, end) = propagate_flow(nx, ny, vp);
  } while (end == std::pair(nx, ny)); //TODO: добавить
  ```
  Логика такого изменения исходит из способа работы `propagate_flow` - поиск циклов скоростей и изменение только тех
  ячеек, что входят в цикл, при чём за один проход изменение ячейки разрешено лишь единожды. Таким образом имеет смысл
  сразу заставлять циклы досчитываться до конца, чем ждать перезапуска от вышележащего метода `apply_forces_on_flow`

  Тесты показали ускорение за счёт только этого улучшения где-то в 2,5-3 раза

- Оптимизирован вызов метода get класса VectorField (Значительное ускорение работы `propagate_flow`)

## Распараллеливание программы

- Добавлен базовый класс `Task` и самописный ThreadPool(`WorkerHandler` в коде)
- Выявлены функции, которые можно безболезненно(без риска race condition) перевести в многопоточное исполнение, в
  частности это
    - `apply_external_forces`
    - `apply_p_forces`
    - Вывод массива на экран

  Для них созданы `ApplyGTask`, `ApplyPTask`, `OutFieldTask`

- Выявлена функция для которой можно решить race condition простыми методами синхронизации потоков - `recalculate_p`

  Для неё создана `RecalcPTask`

## Тестирование

Все программы тестировались на поле `field.txt`, целью был просчёт 10'000 тиков.

В файле `field.txt` расширенное в высоту до размеров (94, 84) поле из исходного файла задания.

Для вычисления времени использовалась одна и та же подвязка в коде:

```cpp
auto timer = std::chrono::steady_clock::now();
for (int i = 0; i < T; ++i) {
    // Вычисление тика
    
    if (i == 10'000) {
        break;
    }
}
std::cout << std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - timer).count() << std::endl;
```

Для запуска всех программ использовалась опция компилятора **"-O0"**

Для оптимизированной программы использовались **одинаковые типы данных** `FIXED(64,8)`, размеры поля - **статические**

Запуск проводился для 3-х конфигураций:

* **Стартовый файл** `fluid.cpp` с расширенным полем.
* **Оптимизированная программа** `main.cpp` **с одним потоком** исполнения, **без отдельного потока для вывода** поля
* **Оптимизированная программа** `main.cpp` **с восьмью потоками** + **поток для вывода** поля на экран

**Результаты следующие (В секундах):**

1) 3378
2) 157
3) 116

**Очевидно значительное ускорение скорости работы алгоритма**, а вот распараллеливание удалось применить лишь для
оптимизации на 25%.

**По критериям:** выполнены полностью пункты 1-4, а также может быть 6; частично - пункт 5